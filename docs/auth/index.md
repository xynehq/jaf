# Authentication Overview

JAF provides built-in support for authenticating tools that call protected APIs. It follows a model similar to ADK: tools declare an `AuthScheme` and an initial `AuthCredential`; the framework pauses and drives an interactive OAuth/OIDC flow when needed, exchanges codes for tokens, caches tokens securely, and retries the tool call automatically.

- Schemes supported: API Key, HTTP Bearer, OAuth2 (Authorization Code, PKCE), OpenID Connect (OIDC Discovery).
- Token storage: pluggable `AuthStore` (in-memory, Redis, Postgres) with optional AWS KMS encryption at rest.
- Interactive flow: `tool_auth` interruption, `/auth/stream` SSE, and `/auth/submit` endpoint.

Use this section to learn how to integrate auth with your tools, configure the server endpoints, and select a production-ready storage backend.

Recommended builder
- For HTTP/REST tools, prefer the generic `makeHttpTool` utility with optional `auth`. It removes all auth code from your tool’s execute and handles pause/resume, token exchange, and header injection for API Key/Bearer/OAuth2/OIDC. See Tool API: auth/tool-auth.md.

## Using JAF Without the Built‑in Server (OIDC Example)

You can embed JAF directly in your own server and still use the interactive auth flow. At a high level:

1) Run the engine and detect `tool_auth` interruption.
2) Extract the provider `authorizationUrl` and the embedded `state` value.
3) Redirect your user to the provider with your `redirect_uri`.
4) In your own callback route, read the full callback URL and submit it to JAF’s AuthStore.
5) Call the engine again to resume; JAF exchanges the code and retries the tool.

Example (Node + Express + OIDC)

```ts
import express from 'express';
import { run, type RunState, type RunConfig } from '@xynehq/jaf';
import { createAuthStoreFromEnv } from '@xynehq/jaf';

// 1) Set up shared AuthStore and a mapping from provider state -> authKey
const authStore = await createAuthStoreFromEnv();
const stateToAuthKey = new Map<string, string>();

// 2) Start a run and detect tool_auth
async function startInteraction(initialState: RunState<any>, config: RunConfig<any>) {
  const result = await run(initialState, config);
  if (result.outcome.status !== 'interrupted') return result;

  const authIntr = result.outcome.interruptions.find(i => i.type === 'tool_auth');
  if (!authIntr) return result; // not an auth interruption

  // authorizationUrl includes a random state generated by JAF
  const authKey = authIntr.auth.authKey;
  const url = new URL(authIntr.auth.authorizationUrl!);
  const providerState = url.searchParams.get('state')!;
  stateToAuthKey.set(providerState, authKey);

  // Append your own redirect_uri and send user to login
  url.searchParams.set('redirect_uri', process.env.AUTH_REDIRECT_URI!);
  const redirectUrl = url.toString();
  // Return this URL to your frontend to open in the browser
  return { ...result, auth: { redirectUrl } } as const;
}

// 3) Your own OAuth callback (must match your provider configuration)
const app = express();
app.get('/oidc/callback', async (req, res) => {
  try {
    const fullUrl = `${req.protocol}://${req.get('host')}${req.originalUrl}`;
    const providerState = req.query.state as string;
    const authKey = stateToAuthKey.get(providerState);
    if (!authKey) return res.status(400).send('Unknown or expired state');

    await authStore.setAuthResponse(authKey, {
      authResponseUri: fullUrl,
      redirectUri: process.env.AUTH_REDIRECT_URI,
    });
    stateToAuthKey.delete(providerState);
    res.status(200).send('✅ Auth received. You can close this tab.');
  } catch (e: any) {
    res.status(500).send(e.message || 'Callback error');
  }
});

// 4) Resume: call run() again with the same conversation/run context
// JAF will exchange the code for tokens (using the AuthStore submission) and retry the tool.
```

Notes
- Prefer `authKey` + `state` binding: store a short‑lived mapping from `state` → `authKey` when the interruption occurs. On callback, derive the `authKey` using the provider’s `state` parameter and call `authStore.setAuthResponse`.
- Do not place callback URLs or tokens into conversation messages or logs. Keep them out of memory providers and redact from traces.
- Token storage: use Redis/Postgres stores with optional AWS KMS encryption in production (see Storage and KMS docs).
- If you do use the bundled server, you can rely on `/auth/stream` and `/auth/submit` out of the box to reduce boilerplate.
